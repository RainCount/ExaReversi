<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>三角形黑白棋棋盘</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/two.js/0.7.0/two.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #5a5a5a;
        }
        #draw-shapes {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="draw-shapes"></div>
    <script>
        var createTriangleBoard = function(two, boardStructure, colors, rotation) {
            var width = window.innerWidth > window.innerHeight ? window.innerHeight : window.innerWidth;
            var sideLength = width / 7; // 三角形的边长
            var height = sideLength * Math.sqrt(3) / 2; // 等边三角形的高

            // 获取屏幕的中心坐标
            var centerX = two.width / 2;
            var centerY = two.height / 2;

            // 绘制上半部分的棋盘
            var group = two.makeGroup(); // 创建一个组来存储所有三角形
            boardStructure.forEach((numTriangles, rowIndex) => {
                var y = centerY - (boardStructure.length / 2 * height) + rowIndex * height;
                for (var i = 0; i < numTriangles; i++) {
                    var x = centerX - (numTriangles - 1) * sideLength / 2 + i * sideLength;
                    var triangle = two.makePolygon(x, y, sideLength / 2, 3);
                    triangle.noStroke();
                    triangle.fill = colors;
                    triangle.rotation = rotation;

                    group.add(triangle); // 将三角形添加到组中
                }
            });
            group.translation.set(0, rotation === 0 ? sideLength / 7 : -sideLength / 7);

            two.update();
        };

        var colors = { up: '#88d675', down: '#ffd34e' , colorP1: '#000000', colorP2: '#FFFFFF', colorPre: '#4DC4FF'}; // 三角形的颜色

        var elem = document.getElementById('draw-shapes');
        var two = new Two({ 
            fullscreen: true, 
            autostart: true 
        }).appendTo(elem);

        createTriangleBoard(two, [4, 5, 6, 5, 4, 3], colors.up, 0);
        createTriangleBoard(two, [3, 4, 5, 6, 5, 4], colors.down, Math.PI);

        //创建一个类，用于存储棋子的状态
        class Board {
            constructor() {
                this.rows = [
                    // 横行
                    [1, 2, 3, 4, 5, 6, 7],
                    [8, 9, 10, 11, 12, 13, 14, 15, 16],
                    [17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27],
                    [28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38],
                    [39, 40, 41, 42, 43, 44, 45, 46, 47],
                    [48, 49, 50, 51, 52, 53, 54],
                    // 左斜行
                    [2, 1, 9, 8, 18, 17, 28],
                    [4, 3, 11, 10, 20, 19, 30, 29, 39],
                    [6, 5, 13, 12, 22, 21, 32, 31, 41, 40, 48],
                    [7, 15, 14, 24, 23, 34, 33, 43, 42, 50, 49],
                    [16, 26, 25, 36, 35, 45, 44, 52, 51],
                    [27, 38, 37, 47, 46, 54, 53],
                    // 右斜行
                    [6, 7, 15, 16, 26, 27, 38],
                    [4, 5, 13, 14, 24, 25, 36, 37, 47],
                    [2, 3, 11, 12, 22, 23, 34, 35, 45, 46, 54],
                    [1, 9, 10, 20, 21, 32, 33, 43, 44, 52, 53],
                    [8, 18, 19, 30, 31, 41, 42, 50, 51],
                    [17, 28, 29, 39, 40, 48, 49]
                ];
                this.pieces = [];
                for (let i = 1; i <= 54; i++) {
                    this.pieces[i] = new Piece(i, null); // 初始时，棋子的颜色为null
                }

                this.pieces[21].color = "#000000";
                this.pieces[23].color = "#000000";
                this.pieces[33].color = "#000000";
                this.pieces[22].color = "#FFFFFF";
                this.pieces[32].color = "#FFFFFF";
                this.pieces[34].color = "#FFFFFF";

                console.log(this.pieces);
                console.log(this.rows.length);
            }

            //判断某个棋子是否可以被放置
            canPlace(pieceId, color) {
                let piece = this.pieces[pieceId];
                if (piece.color === "#4DC4FF") {
                    piece.color = null;
                }
                if (piece.color !== null) {
                    return false; // 如果棋子已经有颜色了，那么它不能被放置
                }
                let opponentColor = color === "#000000" ? "#FFFFFF" : "#000000";
                // 遍历所有的行，查找包含这个棋子的行
                for (let i = 0; i < this.rows.length; i++) {
                    let row = this.rows[i];
                    let index = row.indexOf(pieceId);
                    if (index !== -1) {
                        // 如果找到了包含这个棋子的行，那么判断这个棋子是否可以被放置
                        // 检查这个棋子左边和右边是否有对方的棋子，如果有，那么这个棋子就可以被放置
                        if (index > 0 && this.pieces[row[index - 1]].color === opponentColor) {
                            // 检查对方的棋子的左边是否有自己的棋子
                            for (let j = index - 2; j >= 0; j--) {
                                if (this.pieces[row[j]].color === null || this.pieces[row[j]].color === "#4DC4FF") {
                                    break;
                                } else if (this.pieces[row[j]].color === color) {
                                    this.pieces[pieceId].color = "#4DC4FF";
                                    return true;
                                }
                            }
                        }
                        if (index < row.length - 1 && this.pieces[row[index + 1]].color === opponentColor) {
                            // 检查对方的棋子的右边是否有自己的棋子
                            for (let j = index + 2; j < row.length; j++) {
                                if (this.pieces[row[j]].color === null || this.pieces[row[j]].color === "#4DC4FF") {
                                    break;
                                } else if (this.pieces[row[j]].color === color) {
                                    this.pieces[pieceId].color = "#4DC4FF";
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }

            //按照棋盘的布局，输出棋盘的状态
            printBoard() {
                for (let i = 0; i < 6; i++) {
                    let row = this.rows[i];
                    let rowStatus = "";

                    if(i === 0 || i === 5){
                        rowStatus += "  ";
                    }
                    if(i === 1 || i === 4){
                        rowStatus += " ";
                    }

                    for (let j = 0; j < row.length; j++) {
                        let piece = this.pieces[row[j]];
                        if (piece.color === null) {
                            rowStatus += "0";
                        } else if (piece.color === "#000000") {
                            rowStatus += "B";
                        } else if (piece.color === "#FFFFFF") {
                            rowStatus += "W";
                        } else if (piece.color === "#4DC4FF") {
                            rowStatus += "X";
                        }
                    }
                    console.log(rowStatus);
                }
            }

        }

        class Piece {
            constructor(id, color) {
                this.id = id;
                this.color = color;
            }

            flip() {
                if (this.color === '#000000') {
                    this.color = '#FFFFFF';
                } else if (this.color === '#FFFFFF') {
                    this.color = '#000000';
                }
            }
        }

        class Game {
            constructor() {
                this.board = new Board();
                this.currentPlayer = "#000000"; // 黑子先下
            }

            // 判断当前玩家是否有合法的落子位置
            hasLegalMove() {
                let result = false;
                for (let i = 1; i <= 54; i++) {
                    if (this.board.canPlace(i, this.currentPlayer)) {
                        result = true;
                    }
                }
                return result;
            }

            // 落子并翻转对方的棋子
            makeMove(pieceId) {
                if (this.board.canPlace(pieceId, this.currentPlayer)) {
                    this.board.pieces[pieceId].color = this.currentPlayer;
                    this.flipOpponentPieces(pieceId);
                    this.switchPlayer();
                } else {
                    console.log("Illegal move!");
                }
            }

            // 翻转对方的棋子
            flipOpponentPieces(pieceId) {
                let opponentColor = this.currentPlayer === "#000000" ? "#FFFFFF" : "#000000";
                    let flipList = []; // 添加一个等待翻转的列表
                // 遍历所有的行，查找包含这个棋子的行
                for (let i = 0; i < this.board.rows.length; i++) {
                    let row = this.board.rows[i];
                    let index = row.indexOf(pieceId);
                    if (index !== -1) {
                        // 如果找到了包含这个棋子的行，那么判断这个棋子是否可以被放置
                        // 检查这个棋子左边和右边是否有对方的棋子，如果有，那么这个棋子就可以被放置
                        if (index > 0 && this.board.pieces[row[index - 1]].color === opponentColor) {
                            // 检查对方的棋子的左边是否有自己的棋子
                            for (let j = index - 2; j >= 0; j--) {
                                if (this.board.pieces[row[j]].color === null || this.board.pieces[row[j]].color === "#4DC4FF") {
                                    break;
                                } else if (this.board.pieces[row[j]].color === this.currentPlayer) {
                                    for (let k = j + 1; k < index; k++) {
                                        if (!flipList.includes(row[k])) { // 检查棋子是否已经在列表中
                                            flipList.push(row[k]); // 如果不在列表中，就添加到列表中
                                        }
                                    }
                                    break;
                                }
                            }
                        }
                        if (index < row.length - 1 && this.board.pieces[row[index + 1]].color === opponentColor) {
                            // 检查对方的棋子的右边是否有自己的棋子
                            for (let j = index + 2; j < row.length; j++) {
                                if (this.board.pieces[row[j]].color === null || this.board.pieces[row[j]].color === "#4DC4FF") {
                                    break;
                                } else if (this.board.pieces[row[j]].color === this.currentPlayer) {
                                    for (let k = index + 1; k < j; k++) {
                                        if (!flipList.includes(row[k])) { // 检查棋子是否已经在列表中
                                            flipList.push(row[k]); // 如果不在列表中，就添加到列表中
                                        }
                                    }
                                    break;
                                }
                            }
                        }
                    }                   
                }
                // 在所有可能的行都判断完毕后进行翻转
                for (let i = 0; i < flipList.length; i++) {
                    this.board.pieces[flipList[i]].flip();
                } 
            }

            // 切换当前玩家
            switchPlayer(attempts = 0) {
                if (this.currentPlayer === "#000000") {
                    this.currentPlayer = "#FFFFFF";
                } else {
                    this.currentPlayer = "#000000";
                }
                if (!this.hasLegalMove()) {
                    if (attempts < 1) {
                        console.log("No legal move for " + this.currentPlayer + ", switch to the other player.");
                        this.switchPlayer(attempts + 1);
                    } else {
                        console.log("No legal moves for both players. Game over.");
                        // 这里可以添加游戏结束的代码
                        let score = this.getScore();
                        console.log("Final score: " + JSON.stringify(score));
                        if (score.black > score.white) {
                            console.log("Black wins!");
                        } else if (score.black < score.white) {
                            console.log("White wins!");
                        } else {
                            console.log("It's a tie!");
                        }
                        renderMap();
                    }
                }
            }

            getScore() {
                let blackScore = 0;
                let whiteScore = 0;
                for (let i = 1; i <= 54; i++) {
                    let piece = this.board.pieces[i];
                    if (piece.color === "#000000") {
                        blackScore++;
                    } else if (piece.color === "#FFFFFF") {
                        whiteScore++;
                    }
                }
                return {
                    black: blackScore,
                    white: whiteScore
                };
            }
        }
        

        let idMapping = {
            'two-2': 1, 'two-30': 2, 'two-3': 3, 'two-31': 4, 'two-4': 5, 'two-32': 6, 'two-5': 7,
            'two-6': 8, 'two-33': 9, 'two-7': 10, 'two-34': 11, 'two-8': 12, 'two-35': 13, 'two-9': 14, 'two-36': 15, 'two-10': 16,
            'two-11': 17, 'two-37': 18, 'two-12': 19, 'two-38': 20, 'two-13': 21, 'two-39': 22, 'two-14': 23, 'two-40': 24, 'two-15': 25, 'two-41': 26, 'two-16': 27,
            'two-42': 28, 'two-17': 29, 'two-43': 30, 'two-18': 31, 'two-44': 32, 'two-19': 33, 'two-45': 34, 'two-20': 35, 'two-46': 36, 'two-21': 37, 'two-47': 38,
            'two-48': 39, 'two-22': 40, 'two-49': 41, 'two-23': 42, 'two-50': 43, 'two-24': 44, 'two-51': 45, 'two-25': 46, 'two-52': 47,
            'two-53': 48, 'two-26': 49, 'two-54': 50, 'two-27': 51, 'two-55': 52, 'two-28': 53, 'two-56': 54
        };

        let userInputResolve = null;

        function initialize() {
            for (let i = 2; i <= 28; i++) {
                let elem = document.getElementById('two-' + i);
                if (elem) {
                    let id = idMapping[elem.id];
                    elem.addEventListener('click', function() {
                        // console.log(id);
                        if (userInputResolve) {
                            userInputResolve(id);
                            userInputResolve = null;
                        }
                    });
                    elem.setAttribute('fill', game.board.pieces[id].color === null ? colors.up : game.board.pieces[id].color);
                }
            }
            for (let i = 30; i <= 56; i++) {
                let elem = document.getElementById('two-' + i);
                if (elem) {
                    let id = idMapping[elem.id];
                    elem.addEventListener('click', function() {
                        // console.log(id);
                        if (userInputResolve) {
                            userInputResolve(id);
                            userInputResolve = null;
                        }
                    });
                    elem.setAttribute('fill', game.board.pieces[id].color === null ? colors.down : game.board.pieces[id].color);
                }
            }
        }

        function renderMap() {
            for (let i = 2; i <= 28; i++) {
                let elem = document.getElementById('two-' + i);
                if (elem) {
                    elem.setAttribute('fill', game.board.pieces[idMapping[elem.id]].color === null ? colors.up : game.board.pieces[idMapping[elem.id]].color);
                }
            }
            for (let i = 30; i <= 56; i++) {
                let elem = document.getElementById('two-' + i);
                if (elem) {
                    elem.setAttribute('fill', game.board.pieces[idMapping[elem.id]].color === null ? colors.down : game.board.pieces[idMapping[elem.id]].color);
                }
            }
            game.board.printBoard();
        }

        let game = new Game();
        game.board.printBoard();
        initialize();

        async function main() {
            while (game.hasLegalMove()) {
                console.log("Current player: " + game.currentPlayer);
                console.log("Score: " + JSON.stringify(game.getScore()));
                renderMap();
                let pieceId = await getUserInput();
                // console.log(pieceId);
                game.makeMove(pieceId);
            }

            console.log("Game over!");
        }

        function getUserInput() {
            return new Promise(resolve => {
                userInputResolve = resolve;
            });
        }

        main();

    </script>
</body>
</html>
